{
  "version": 3,
  "sources": ["../../ol/xml.js", "../../ol/format/XMLFeature.js", "../../ol/format/xsd.js", "../../ol/format/KML.js", "dep:ol_format_KML"],
  "sourcesContent": ["/**\n * @module ol/xml\n */\nimport {extend} from './array.js';\n\n/**\n * When using {@link module:ol/xml.makeChildAppender} or\n * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Element} node Node.\n */\n\n/**\n * @typedef {function(Element, Array<*>): void} Parser\n */\n\n/**\n * @typedef {function(Element, *, Array<*>): void} Serializer\n */\n\n/**\n * @type {string}\n */\nexport const XML_SCHEMA_INSTANCE_URI =\n  'http://www.w3.org/2001/XMLSchema-instance';\n\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\nexport function createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\nexport function getAllTextContent(node, normalizeWhitespace) {\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n  if (\n    node.nodeType == Node.CDATA_SECTION_NODE ||\n    node.nodeType == Node.TEXT_NODE\n  ) {\n    if (normalizeWhitespace) {\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      accumulator.push(node.nodeValue);\n    }\n  } else {\n    let n;\n    for (n = node.firstChild; n; n = n.nextSibling) {\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\n    }\n  }\n  return accumulator;\n}\n\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\nexport function isDocument(object) {\n  return 'documentElement' in object;\n}\n\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\nexport function getAttributeNS(node, namespaceURI, name) {\n  return node.getAttributeNS(namespaceURI, name) || '';\n}\n\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\nexport function parse(xml) {\n  return new DOMParser().parseFromString(xml, 'application/xml');\n}\n\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayExtender(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        extend(array, value);\n      }\n    }\n  );\n}\n\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayPusher(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeReplacer(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        objectStack[objectStack.length - 1] = value;\n      }\n    }\n  );\n}\n\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertyPusher(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        let array;\n        if (name in object) {\n          array = object[name];\n        } else {\n          array = [];\n          object[name] = array;\n        }\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertySetter(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        object[name] = value;\n      }\n    }\n  );\n}\n\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeChildAppender(nodeWriter, thisArg) {\n  return function (node, value, objectStack) {\n    nodeWriter.call(\n      thisArg !== undefined ? thisArg : this,\n      node,\n      value,\n      objectStack\n    );\n    const parent = /** @type {NodeStackItem} */ (\n      objectStack[objectStack.length - 1]\n    );\n    const parentNode = parent.node;\n    parentNode.appendChild(node);\n  };\n}\n\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the\n * `nodeWriter` called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeArraySerializer(nodeWriter, thisArg) {\n  let serializersNS, nodeFactory;\n  return function (node, value, objectStack) {\n    if (serializersNS === undefined) {\n      serializersNS = {};\n      const serializers = {};\n      serializers[node.localName] = nodeWriter;\n      serializersNS[node.namespaceURI] = serializers;\n      nodeFactory = makeSimpleNodeFactory(node.localName);\n    }\n    serialize(serializersNS, nodeFactory, value, objectStack);\n  };\n}\n\n/**\n * Create a node factory which can use the `keys` passed to\n * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string} [fixedNodeName] Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string} [fixedNamespaceURI] Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\nexport function makeSimpleNodeFactory(fixedNodeName, fixedNamespaceURI) {\n  return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [newNodeName] Node name.\n     * @return {Node} Node.\n     */\n    function (value, objectStack, newNodeName) {\n      const context = /** @type {NodeStackItem} */ (\n        objectStack[objectStack.length - 1]\n      );\n      const node = context.node;\n      let nodeName = fixedNodeName;\n      if (nodeName === undefined) {\n        nodeName = newNodeName;\n      }\n\n      const namespaceURI =\n        fixedNamespaceURI !== undefined ? fixedNamespaceURI : node.namespaceURI;\n      return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\n    }\n  );\n}\n\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nexport const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n\n/**\n * Create an array of `values` to be used with {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `key` argument.\n * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<*>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n */\nexport function makeSequence(object, orderedKeys) {\n  const length = orderedKeys.length;\n  const sequence = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    sequence[i] = object[orderedKeys[i]];\n  }\n  return sequence;\n}\n\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>} [structureNS] Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\nexport function makeStructureNS(namespaceURIs, structure, structureNS) {\n  structureNS = structureNS !== undefined ? structureNS : {};\n  let i, ii;\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n    structureNS[namespaceURIs[i]] = structure;\n  }\n  return structureNS;\n}\n\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n */\nexport function parseNode(parsersNS, node, objectStack, thisArg) {\n  let n;\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n    const parsers = parsersNS[n.namespaceURI];\n    if (parsers !== undefined) {\n      const parser = parsers[n.localName];\n      if (parser !== undefined) {\n        parser.call(thisArg, n, objectStack);\n      }\n    }\n  }\n}\n\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\nexport function pushParseAndPop(object, parsersNS, node, objectStack, thisArg) {\n  objectStack.push(object);\n  parseNode(parsersNS, node, objectStack, thisArg);\n  return /** @type {T} */ (objectStack.pop());\n}\n\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\nexport function serialize(\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg\n) {\n  const length = (keys !== undefined ? keys : values).length;\n  let value, node;\n  for (let i = 0; i < length; ++i) {\n    value = values[i];\n    if (value !== undefined) {\n      node = nodeFactory.call(\n        thisArg !== undefined ? thisArg : this,\n        value,\n        objectStack,\n        keys !== undefined ? keys[i] : undefined\n      );\n      if (node !== undefined) {\n        serializersNS[node.namespaceURI][node.localName].call(\n          thisArg,\n          node,\n          value,\n          objectStack\n        );\n      }\n    }\n  }\n}\n\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\nexport function pushSerializeAndPop(\n  object,\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg\n) {\n  objectStack.push(object);\n  serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg);\n  return /** @type {O|undefined} */ (objectStack.pop());\n}\n\nlet xmlSerializer_ = undefined;\n\n/**\n * Register a XMLSerializer. Can be used  to inject a XMLSerializer\n * where there is no globally available implementation.\n *\n * @param {XMLSerializer} xmlSerializer A XMLSerializer.\n * @api\n */\nexport function registerXMLSerializer(xmlSerializer) {\n  xmlSerializer_ = xmlSerializer;\n}\n\n/**\n * @return {XMLSerializer} The XMLSerializer.\n */\nexport function getXMLSerializer() {\n  if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {\n    xmlSerializer_ = new XMLSerializer();\n  }\n  return xmlSerializer_;\n}\n\nlet document_ = undefined;\n\n/**\n * Register a Document to use when creating nodes for XML serializations. Can be used\n * to inject a Document where there is no globally available implementation.\n *\n * @param {Document} document A Document.\n * @api\n */\nexport function registerDocument(document) {\n  document_ = document;\n}\n\n/**\n * Get a document that should be used when creating nodes for XML serializations.\n * @return {Document} The document.\n */\nexport function getDocument() {\n  if (document_ === undefined && typeof document !== 'undefined') {\n    document_ = document.implementation.createDocument('', '', null);\n  }\n  return document_;\n}\n", "/**\n * @module ol/format/XMLFeature\n */\nimport FeatureFormat from '../format/Feature.js';\nimport {abstract} from '../util.js';\nimport {extend} from '../array.js';\nimport {getXMLSerializer, isDocument, parse} from '../xml.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for XML feature formats.\n *\n * @abstract\n */\nclass XMLFeature extends FeatureFormat {\n  constructor() {\n    super();\n\n    /**\n     * @type {XMLSerializer}\n     * @private\n     */\n    this.xmlSerializer_ = getXMLSerializer();\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   */\n  getType() {\n    return 'xml';\n  }\n\n  /**\n   * Read a single feature.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   */\n  readFeature(source, options) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureFromDocument(doc, options);\n    } else if (isDocument(source)) {\n      return this.readFeatureFromDocument(\n        /** @type {Document} */ (source),\n        options\n      );\n    } else {\n      return this.readFeatureFromNode(/** @type {Element} */ (source), options);\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromDocument(doc, options) {\n    const features = this.readFeaturesFromDocument(doc, options);\n    if (features.length > 0) {\n      return features[0];\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromNode(node, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read all features from a feature collection.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  readFeatures(source, options) {\n    if (!source) {\n      return [];\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeaturesFromDocument(doc, options);\n    } else if (isDocument(source)) {\n      return this.readFeaturesFromDocument(\n        /** @type {Document} */ (source),\n        options\n      );\n    } else {\n      return this.readFeaturesFromNode(\n        /** @type {Element} */ (source),\n        options\n      );\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromDocument(doc, options) {\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    const features = [];\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(\n          features,\n          this.readFeaturesFromNode(/** @type {Element} */ (n), options)\n        );\n      }\n    }\n    return features;\n  }\n\n  /**\n   * @abstract\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometry(source, options) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readGeometryFromDocument(doc, options);\n    } else if (isDocument(source)) {\n      return this.readGeometryFromDocument(\n        /** @type {Document} */ (source),\n        options\n      );\n    } else {\n      return this.readGeometryFromNode(\n        /** @type {Element} */ (source),\n        options\n      );\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromDocument(doc, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromNode(node, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read the projection from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   */\n  readProjection(source) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readProjectionFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readProjectionFromDocument(/** @type {Document} */ (source));\n    } else {\n      return this.readProjectionFromNode(/** @type {Element} */ (source));\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromDocument(doc) {\n    return this.dataProjection;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    return this.dataProjection;\n  }\n\n  /**\n   * Encode a feature as string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   */\n  writeFeature(feature, options) {\n    const node = this.writeFeatureNode(feature, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @protected\n   * @return {Node} Node.\n   */\n  writeFeatureNode(feature, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Result.\n   * @api\n   */\n  writeFeatures(features, options) {\n    const node = this.writeFeaturesNode(features, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   */\n  writeFeaturesNode(features, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode a geometry as string.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded geometry.\n   */\n  writeGeometry(geometry, options) {\n    const node = this.writeGeometryNode(geometry, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   */\n  writeGeometryNode(geometry, options) {\n    return null; // not implemented\n  }\n}\n\nexport default XMLFeature;\n", "/**\n * @module ol/format/xsd\n */\nimport {getAllTextContent, getDocument} from '../xml.js';\nimport {padNumber} from '../string.js';\n\n/**\n * @param {Node} node Node.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBoolean(node) {\n  const s = getAllTextContent(node, false);\n  return readBooleanString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBooleanString(string) {\n  const m = /^\\s*(true|1)|(false|0)\\s*$/.exec(string);\n  if (m) {\n    return m[1] !== undefined || false;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} DateTime in seconds.\n */\nexport function readDateTime(node) {\n  const s = getAllTextContent(node, false);\n  const dateTime = Date.parse(s);\n  return isNaN(dateTime) ? undefined : dateTime / 1000;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimal(node) {\n  const s = getAllTextContent(node, false);\n  return readDecimalString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimalString(string) {\n  // FIXME check spec\n  const m = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)\\s*$/i.exec(string);\n  if (m) {\n    return parseFloat(m[1]);\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Non negative integer.\n */\nexport function readPositiveInteger(node) {\n  const s = getAllTextContent(node, false);\n  return readNonNegativeIntegerString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Non negative integer.\n */\nexport function readNonNegativeIntegerString(string) {\n  const m = /^\\s*(\\d+)\\s*$/.exec(string);\n  if (m) {\n    return parseInt(m[1], 10);\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {string|undefined} String.\n */\nexport function readString(node) {\n  return getAllTextContent(node, false).trim();\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the boolean to.\n * @param {boolean} bool Boolean.\n */\nexport function writeBooleanTextNode(node, bool) {\n  writeStringTextNode(node, bool ? '1' : '0');\n}\n\n/**\n * @param {Node} node Node to append a CDATA Section with the string to.\n * @param {string} string String.\n */\nexport function writeCDATASection(node, string) {\n  node.appendChild(getDocument().createCDATASection(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the dateTime to.\n * @param {number} dateTime DateTime in seconds.\n */\nexport function writeDateTimeTextNode(node, dateTime) {\n  const date = new Date(dateTime * 1000);\n  const string =\n    date.getUTCFullYear() +\n    '-' +\n    padNumber(date.getUTCMonth() + 1, 2) +\n    '-' +\n    padNumber(date.getUTCDate(), 2) +\n    'T' +\n    padNumber(date.getUTCHours(), 2) +\n    ':' +\n    padNumber(date.getUTCMinutes(), 2) +\n    ':' +\n    padNumber(date.getUTCSeconds(), 2) +\n    'Z';\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} decimal Decimal.\n */\nexport function writeDecimalTextNode(node, decimal) {\n  const string = decimal.toPrecision();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} nonNegativeInteger Non negative integer.\n */\nexport function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {\n  const string = nonNegativeInteger.toString();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the string to.\n * @param {string} string String.\n */\nexport function writeStringTextNode(node, string) {\n  node.appendChild(getDocument().createTextNode(string));\n}\n", "/**\n * @module ol/format/KML\n */\nimport Feature from '../Feature.js';\nimport Fill from '../style/Fill.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport Icon from '../style/Icon.js';\nimport ImageState from '../ImageState.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport Stroke from '../style/Stroke.js';\nimport Style from '../style/Style.js';\nimport Text from '../style/Text.js';\nimport XMLFeature from './XMLFeature.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  XML_SCHEMA_INSTANCE_URI,\n  createElementNS,\n  getAllTextContent,\n  isDocument,\n  makeArrayExtender,\n  makeArrayPusher,\n  makeChildAppender,\n  makeObjectPropertySetter,\n  makeReplacer,\n  makeSequence,\n  makeSimpleNodeFactory,\n  makeStructureNS,\n  parse,\n  parseNode,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {asArray} from '../color.js';\nimport {assert} from '../asserts.js';\nimport {extend} from '../array.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  readBoolean,\n  readDecimal,\n  readString,\n  writeBooleanTextNode,\n  writeCDATASection,\n  writeDecimalTextNode,\n  writeStringTextNode,\n} from './xsd.js';\nimport {toRadians} from '../math.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * @typedef {Object} Vec2\n * @property {number} x X coordinate.\n * @property {import(\"../style/Icon.js\").IconAnchorUnits} xunits Units of x.\n * @property {number} y Y coordinate.\n * @property {import(\"../style/Icon.js\").IconAnchorUnits} yunits Units of Y.\n * @property {import(\"../style/Icon.js\").IconOrigin} [origin] Origin.\n */\n\n/**\n * @typedef {Object} GxTrackObject\n * @property {Array<Array<number>>} coordinates Coordinates.\n * @property {Array<number>} whens Whens.\n */\n\n/**\n * @const\n * @type {Array<string>}\n */\nconst GX_NAMESPACE_URIS = ['http://www.google.com/kml/ext/2.2'];\n\n/**\n * @const\n * @type {Array<null|string>}\n */\nconst NAMESPACE_URIS = [\n  null,\n  'http://earth.google.com/kml/2.0',\n  'http://earth.google.com/kml/2.1',\n  'http://earth.google.com/kml/2.2',\n  'http://www.opengis.net/kml/2.2',\n];\n\n/**\n * @const\n * @type {string}\n */\nconst SCHEMA_LOCATION =\n  'http://www.opengis.net/kml/2.2 ' +\n  'https://developers.google.com/kml/schema/kml22gx.xsd';\n\n/**\n * @type {Object<string, import(\"../style/Icon.js\").IconAnchorUnits>}\n */\nconst ICON_ANCHOR_UNITS_MAP = {\n  'fraction': 'fraction',\n  'pixels': 'pixels',\n  'insetPixels': 'pixels',\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PLACEMARK_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'ExtendedData': extendedDataParser,\n    'Region': regionParser,\n    'MultiGeometry': makeObjectPropertySetter(readMultiGeometry, 'geometry'),\n    'LineString': makeObjectPropertySetter(readLineString, 'geometry'),\n    'LinearRing': makeObjectPropertySetter(readLinearRing, 'geometry'),\n    'Point': makeObjectPropertySetter(readPoint, 'geometry'),\n    'Polygon': makeObjectPropertySetter(readPolygon, 'geometry'),\n    'Style': makeObjectPropertySetter(readStyle),\n    'StyleMap': placemarkStyleMapParser,\n    'address': makeObjectPropertySetter(readString),\n    'description': makeObjectPropertySetter(readString),\n    'name': makeObjectPropertySetter(readString),\n    'open': makeObjectPropertySetter(readBoolean),\n    'phoneNumber': makeObjectPropertySetter(readString),\n    'styleUrl': makeObjectPropertySetter(readStyleURL),\n    'visibility': makeObjectPropertySetter(readBoolean),\n  },\n  makeStructureNS(GX_NAMESPACE_URIS, {\n    'MultiTrack': makeObjectPropertySetter(readGxMultiTrack, 'geometry'),\n    'Track': makeObjectPropertySetter(readGxTrack, 'geometry'),\n  })\n);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst NETWORK_LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'ExtendedData': extendedDataParser,\n  'Region': regionParser,\n  'Link': linkParser,\n  'address': makeObjectPropertySetter(readString),\n  'description': makeObjectPropertySetter(readString),\n  'name': makeObjectPropertySetter(readString),\n  'open': makeObjectPropertySetter(readBoolean),\n  'phoneNumber': makeObjectPropertySetter(readString),\n  'visibility': makeObjectPropertySetter(readBoolean),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'href': makeObjectPropertySetter(readURI),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst REGION_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LatLonAltBox': latLonAltBoxParser,\n  'Lod': lodParser,\n});\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst KML_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['Document', 'Placemark']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst KML_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Document': makeChildAppender(writeDocument),\n  'Placemark': makeChildAppender(writePlacemark),\n});\n\n/**\n * @type {import(\"../color.js\").Color}\n */\nlet DEFAULT_COLOR;\n\n/**\n * @type {Fill|null}\n */\nlet DEFAULT_FILL_STYLE = null;\n\n/**\n * Get the default fill style (or null if not yet set).\n * @return {Fill|null} The default fill style.\n */\nexport function getDefaultFillStyle() {\n  return DEFAULT_FILL_STYLE;\n}\n\n/**\n * @type {import(\"../size.js\").Size}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR;\n\n/**\n * @type {import(\"../style/Icon.js\").IconAnchorUnits}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n\n/**\n * @type {import(\"../style/Icon.js\").IconAnchorUnits}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n\n/**\n * @type {import(\"../size.js\").Size}\n */\nlet DEFAULT_IMAGE_STYLE_SIZE;\n\n/**\n * @type {string}\n */\nlet DEFAULT_IMAGE_STYLE_SRC;\n\n/**\n * @type {import(\"../style/Image.js\").default|null}\n */\nlet DEFAULT_IMAGE_STYLE = null;\n\n/**\n * Get the default image style (or null if not yet set).\n * @return {import(\"../style/Image.js\").default|null} The default image style.\n */\nexport function getDefaultImageStyle() {\n  return DEFAULT_IMAGE_STYLE;\n}\n\n/**\n * @type {string}\n */\nlet DEFAULT_NO_IMAGE_STYLE;\n\n/**\n * @type {Stroke|null}\n */\nlet DEFAULT_STROKE_STYLE = null;\n\n/**\n * Get the default stroke style (or null if not yet set).\n * @return {Stroke|null} The default stroke style.\n */\nexport function getDefaultStrokeStyle() {\n  return DEFAULT_STROKE_STYLE;\n}\n\n/**\n * @type {Stroke}\n */\nlet DEFAULT_TEXT_STROKE_STYLE;\n\n/**\n * @type {Text|null}\n */\nlet DEFAULT_TEXT_STYLE = null;\n\n/**\n * Get the default text style (or null if not yet set).\n * @return {Text|null} The default text style.\n */\nexport function getDefaultTextStyle() {\n  return DEFAULT_TEXT_STYLE;\n}\n\n/**\n * @type {Style|null}\n */\nlet DEFAULT_STYLE = null;\n\n/**\n * Get the default style (or null if not yet set).\n * @return {Style|null} The default style.\n */\nexport function getDefaultStyle() {\n  return DEFAULT_STYLE;\n}\n\n/**\n * @type {Array<Style>|null}\n */\nlet DEFAULT_STYLE_ARRAY = null;\n\n/**\n * Get the default style array (or null if not yet set).\n * @return {Array<Style>|null} The default style.\n */\nexport function getDefaultStyleArray() {\n  return DEFAULT_STYLE_ARRAY;\n}\n\n/**\n * Function that returns the scale needed to normalize an icon image to 32 pixels.\n * @param {import(\"../size.js\").Size} size Image size.\n * @return {number} Scale.\n */\nfunction scaleForSize(size) {\n  return 32 / Math.min(size[0], size[1]);\n}\n\nfunction createStyleDefaults() {\n  DEFAULT_COLOR = [255, 255, 255, 1];\n\n  DEFAULT_FILL_STYLE = new Fill({\n    color: DEFAULT_COLOR,\n  });\n\n  DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2];\n\n  DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = 'pixels';\n\n  DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = 'pixels';\n\n  DEFAULT_IMAGE_STYLE_SIZE = [64, 64];\n\n  DEFAULT_IMAGE_STYLE_SRC =\n    'https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png';\n\n  DEFAULT_IMAGE_STYLE = new Icon({\n    anchor: DEFAULT_IMAGE_STYLE_ANCHOR,\n    anchorOrigin: 'bottom-left',\n    anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,\n    anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,\n    crossOrigin: 'anonymous',\n    rotation: 0,\n    scale: scaleForSize(DEFAULT_IMAGE_STYLE_SIZE),\n    size: DEFAULT_IMAGE_STYLE_SIZE,\n    src: DEFAULT_IMAGE_STYLE_SRC,\n  });\n\n  DEFAULT_NO_IMAGE_STYLE = 'NO_IMAGE';\n\n  DEFAULT_STROKE_STYLE = new Stroke({\n    color: DEFAULT_COLOR,\n    width: 1,\n  });\n\n  DEFAULT_TEXT_STROKE_STYLE = new Stroke({\n    color: [51, 51, 51, 1],\n    width: 2,\n  });\n\n  DEFAULT_TEXT_STYLE = new Text({\n    font: 'bold 16px Helvetica',\n    fill: DEFAULT_FILL_STYLE,\n    stroke: DEFAULT_TEXT_STROKE_STYLE,\n    scale: 0.8,\n  });\n\n  DEFAULT_STYLE = new Style({\n    fill: DEFAULT_FILL_STYLE,\n    image: DEFAULT_IMAGE_STYLE,\n    text: DEFAULT_TEXT_STYLE,\n    stroke: DEFAULT_STROKE_STYLE,\n    zIndex: 0,\n  });\n\n  DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];\n}\n\n/**\n * @type {HTMLTextAreaElement}\n */\nlet TEXTAREA;\n\n/**\n * A function that takes a url `{string}` and returns a url `{string}`.\n * Might be used to change an icon path or to substitute a\n * data url obtained from a KMZ array buffer.\n *\n * @typedef {function(string):string} IconUrlFunction\n * @api\n */\n\n/**\n * Function that returns a url unchanged.\n * @param {string} href Input url.\n * @return {string} Output url.\n */\nfunction defaultIconUrlFunction(href) {\n  return href;\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [extractStyles=true] Extract styles from the KML.\n * @property {boolean} [showPointNames=true] Show names as labels for placemarks which contain points.\n * @property {Array<Style>} [defaultStyle] Default style. The\n * default default style is the same as Google Earth.\n * @property {boolean} [writeStyles=true] Write styles into KML.\n * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images. Note that you must provide a\n * `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * @property {IconUrlFunction} [iconUrlFunction] Function that takes a url string and returns a url string.\n * Might be used to change an icon path or to substitute a data url obtained from a KMZ array buffer.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the KML format.\n *\n * {@link module:ol/format/KML~KML#readFeature} will read the first feature from\n * a KML source.\n *\n * MultiGeometries are converted into GeometryCollections if they are a mix of\n * geometry types, and into MultiPoint/MultiLineString/MultiPolygon if they are\n * all of the same type.\n *\n * @api\n */\nclass KML extends XMLFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    if (!DEFAULT_STYLE_ARRAY) {\n      createStyleDefaults();\n    }\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection('EPSG:4326');\n\n    /**\n     * @private\n     * @type {Array<Style>}\n     */\n    this.defaultStyle_ = options.defaultStyle\n      ? options.defaultStyle\n      : DEFAULT_STYLE_ARRAY;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.extractStyles_ =\n      options.extractStyles !== undefined ? options.extractStyles : true;\n\n    /**\n     * @type {boolean}\n     */\n    this.writeStyles_ =\n      options.writeStyles !== undefined ? options.writeStyles : true;\n\n    /**\n     * @private\n     * @type {!Object<string, (Array<Style>|string)>}\n     */\n    this.sharedStyles_ = {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.showPointNames_ =\n      options.showPointNames !== undefined ? options.showPointNames : true;\n\n    /**\n     * @type {null|string}\n     */\n    this.crossOrigin_ =\n      options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';\n\n    /**\n     * @type {IconUrlFunction}\n     */\n    this.iconUrlFunction_ = options.iconUrlFunction\n      ? options.iconUrlFunction\n      : defaultIconUrlFunction;\n\n    this.supportedMediaTypes = ['application/vnd.google-earth.kml+xml'];\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<Feature>|undefined} Features.\n   */\n  readDocumentOrFolder_(node, objectStack) {\n    // FIXME use scope somehow\n    const parsersNS = makeStructureNS(NAMESPACE_URIS, {\n      'Document': makeArrayExtender(this.readDocumentOrFolder_, this),\n      'Folder': makeArrayExtender(this.readDocumentOrFolder_, this),\n      'Placemark': makeArrayPusher(this.readPlacemark_, this),\n      'Style': this.readSharedStyle_.bind(this),\n      'StyleMap': this.readSharedStyleMap_.bind(this),\n    });\n    /** @type {Array<Feature>} */\n    // @ts-ignore\n    const features = pushParseAndPop([], parsersNS, node, objectStack, this);\n    if (features) {\n      return features;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Feature|undefined} Feature.\n   */\n  readPlacemark_(node, objectStack) {\n    const object = pushParseAndPop(\n      {'geometry': null},\n      PLACEMARK_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (!object) {\n      return undefined;\n    }\n    const feature = new Feature();\n    const id = node.getAttribute('id');\n    if (id !== null) {\n      feature.setId(id);\n    }\n    const options = /** @type {import(\"./Feature.js\").ReadOptions} */ (\n      objectStack[0]\n    );\n\n    const geometry = object['geometry'];\n    if (geometry) {\n      transformGeometryWithOptions(geometry, false, options);\n    }\n    feature.setGeometry(geometry);\n    delete object['geometry'];\n\n    if (this.extractStyles_) {\n      const style = object['Style'];\n      const styleUrl = object['styleUrl'];\n      const styleFunction = createFeatureStyleFunction(\n        style,\n        styleUrl,\n        this.defaultStyle_,\n        this.sharedStyles_,\n        this.showPointNames_\n      );\n      feature.setStyle(styleFunction);\n    }\n    delete object['Style'];\n    // we do not remove the styleUrl property from the object, so it\n    // gets stored on feature when setProperties is called\n\n    feature.setProperties(object, true);\n\n    return feature;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n  readSharedStyle_(node, objectStack) {\n    const id = node.getAttribute('id');\n    if (id !== null) {\n      const style = readStyle.call(this, node, objectStack);\n      if (style) {\n        let styleUri;\n        let baseURI = node.baseURI;\n        if (!baseURI || baseURI == 'about:blank') {\n          baseURI = window.location.href;\n        }\n        if (baseURI) {\n          const url = new URL('#' + id, baseURI);\n          styleUri = url.href;\n        } else {\n          styleUri = '#' + id;\n        }\n        this.sharedStyles_[styleUri] = style;\n      }\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n  readSharedStyleMap_(node, objectStack) {\n    const id = node.getAttribute('id');\n    if (id === null) {\n      return;\n    }\n    const styleMapValue = readStyleMapValue.call(this, node, objectStack);\n    if (!styleMapValue) {\n      return;\n    }\n    let styleUri;\n    let baseURI = node.baseURI;\n    if (!baseURI || baseURI == 'about:blank') {\n      baseURI = window.location.href;\n    }\n    if (baseURI) {\n      const url = new URL('#' + id, baseURI);\n      styleUri = url.href;\n    } else {\n      styleUri = '#' + id;\n    }\n    this.sharedStyles_[styleUri] = styleMapValue;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromNode(node, options) {\n    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {\n      return null;\n    }\n    const feature = this.readPlacemark_(node, [\n      this.getReadOptions(node, options),\n    ]);\n    if (feature) {\n      return feature;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @protected\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {\n      return [];\n    }\n    let features;\n    const localName = node.localName;\n    if (localName == 'Document' || localName == 'Folder') {\n      features = this.readDocumentOrFolder_(node, [\n        this.getReadOptions(node, options),\n      ]);\n      if (features) {\n        return features;\n      } else {\n        return [];\n      }\n    } else if (localName == 'Placemark') {\n      const feature = this.readPlacemark_(node, [\n        this.getReadOptions(node, options),\n      ]);\n      if (feature) {\n        return [feature];\n      } else {\n        return [];\n      }\n    } else if (localName == 'kml') {\n      features = [];\n      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n        const fs = this.readFeaturesFromNode(n, options);\n        if (fs) {\n          extend(features, fs);\n        }\n      }\n      return features;\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * Read the name of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {string|undefined} Name.\n   * @api\n   */\n  readName(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readNameFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readNameFromDocument(/** @type {Document} */ (source));\n    } else {\n      return this.readNameFromNode(/** @type {Element} */ (source));\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {string|undefined} Name.\n   */\n  readNameFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        const name = this.readNameFromNode(/** @type {Element} */ (n));\n        if (name) {\n          return name;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {string|undefined} Name.\n   */\n  readNameFromNode(node) {\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'name') {\n        return readString(n);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\n        (localName == 'Document' ||\n          localName == 'Folder' ||\n          localName == 'Placemark' ||\n          localName == 'kml')\n      ) {\n        const name = this.readNameFromNode(n);\n        if (name) {\n          return name;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Read the network links of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {Array<Object>} Network links.\n   * @api\n   */\n  readNetworkLinks(source) {\n    const networkLinks = [];\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      extend(networkLinks, this.readNetworkLinksFromDocument(doc));\n    } else if (isDocument(source)) {\n      extend(\n        networkLinks,\n        this.readNetworkLinksFromDocument(/** @type {Document} */ (source))\n      );\n    } else {\n      extend(\n        networkLinks,\n        this.readNetworkLinksFromNode(/** @type {Element} */ (source))\n      );\n    }\n    return networkLinks;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {Array<Object>} Network links.\n   */\n  readNetworkLinksFromDocument(doc) {\n    const networkLinks = [];\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(\n          networkLinks,\n          this.readNetworkLinksFromNode(/** @type {Element} */ (n))\n        );\n      }\n    }\n    return networkLinks;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Array<Object>} Network links.\n   */\n  readNetworkLinksFromNode(node) {\n    const networkLinks = [];\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\n        n.localName == 'NetworkLink'\n      ) {\n        const obj = pushParseAndPop({}, NETWORK_LINK_PARSERS, n, []);\n        networkLinks.push(obj);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\n        (localName == 'Document' || localName == 'Folder' || localName == 'kml')\n      ) {\n        extend(networkLinks, this.readNetworkLinksFromNode(n));\n      }\n    }\n    return networkLinks;\n  }\n\n  /**\n   * Read the regions of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {Array<Object>} Regions.\n   * @api\n   */\n  readRegion(source) {\n    const regions = [];\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      extend(regions, this.readRegionFromDocument(doc));\n    } else if (isDocument(source)) {\n      extend(\n        regions,\n        this.readRegionFromDocument(/** @type {Document} */ (source))\n      );\n    } else {\n      extend(regions, this.readRegionFromNode(/** @type {Element} */ (source)));\n    }\n    return regions;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {Array<Object>} Region.\n   */\n  readRegionFromDocument(doc) {\n    const regions = [];\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(regions, this.readRegionFromNode(/** @type {Element} */ (n)));\n      }\n    }\n    return regions;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Array<Object>} Region.\n   * @api\n   */\n  readRegionFromNode(node) {\n    const regions = [];\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'Region') {\n        const obj = pushParseAndPop({}, REGION_PARSERS, n, []);\n        regions.push(obj);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\n        (localName == 'Document' || localName == 'Folder' || localName == 'kml')\n      ) {\n        extend(regions, this.readRegionFromNode(n));\n      }\n    }\n    return regions;\n  }\n\n  /**\n   * Encode an array of features in the KML format as an XML node. GeometryCollections,\n   * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.\n   *\n   * @param {Array<Feature>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   * @api\n   */\n  writeFeaturesNode(features, options) {\n    options = this.adaptOptions(options);\n    const kml = createElementNS(NAMESPACE_URIS[4], 'kml');\n    const xmlnsUri = 'http://www.w3.org/2000/xmlns/';\n    kml.setAttributeNS(xmlnsUri, 'xmlns:gx', GX_NAMESPACE_URIS[0]);\n    kml.setAttributeNS(xmlnsUri, 'xmlns:xsi', XML_SCHEMA_INSTANCE_URI);\n    kml.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      SCHEMA_LOCATION\n    );\n\n    const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {\n        node: kml,\n      };\n    /** @type {!Object<string, (Array<Feature>|Feature|undefined)>} */\n    const properties = {};\n    if (features.length > 1) {\n      properties['Document'] = features;\n    } else if (features.length == 1) {\n      properties['Placemark'] = features[0];\n    }\n    const orderedKeys = KML_SEQUENCE[kml.namespaceURI];\n    const values = makeSequence(properties, orderedKeys);\n    pushSerializeAndPop(\n      context,\n      KML_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      [options],\n      orderedKeys,\n      this\n    );\n    return kml;\n  }\n}\n\n/**\n * @param {Style|undefined} foundStyle Style.\n * @param {string} name Name.\n * @return {Style} style Style.\n */\nfunction createNameStyleFunction(foundStyle, name) {\n  const textOffset = [0, 0];\n  /** @type {CanvasTextAlign} */\n  let textAlign = 'start';\n  const imageStyle = foundStyle.getImage();\n  if (imageStyle) {\n    const imageSize = imageStyle.getSize();\n    if (imageSize && imageSize.length == 2) {\n      const imageScale = imageStyle.getScaleArray();\n      const anchor = imageStyle.getAnchor();\n      // Offset the label to be centered to the right of the icon,\n      // if there is one.\n      textOffset[0] = imageScale[0] * (imageSize[0] - anchor[0]);\n      textOffset[1] = imageScale[1] * (imageSize[1] / 2 - anchor[1]);\n      textAlign = 'left';\n    }\n  }\n  let textStyle = foundStyle.getText();\n  if (textStyle) {\n    // clone the text style, customizing it with name, alignments and offset.\n    // Note that kml does not support many text options that OpenLayers does (rotation, textBaseline).\n    textStyle = textStyle.clone();\n    textStyle.setFont(textStyle.getFont() || DEFAULT_TEXT_STYLE.getFont());\n    textStyle.setScale(textStyle.getScale() || DEFAULT_TEXT_STYLE.getScale());\n    textStyle.setFill(textStyle.getFill() || DEFAULT_TEXT_STYLE.getFill());\n    textStyle.setStroke(textStyle.getStroke() || DEFAULT_TEXT_STROKE_STYLE);\n  } else {\n    textStyle = DEFAULT_TEXT_STYLE.clone();\n  }\n  textStyle.setText(name);\n  textStyle.setOffsetX(textOffset[0]);\n  textStyle.setOffsetY(textOffset[1]);\n  textStyle.setTextAlign(textAlign);\n\n  const nameStyle = new Style({\n    image: imageStyle,\n    text: textStyle,\n  });\n  return nameStyle;\n}\n\n/**\n * @param {Array<Style>|undefined} style Style.\n * @param {string} styleUrl Style URL.\n * @param {Array<Style>} defaultStyle Default style.\n * @param {!Object<string, (Array<Style>|string)>} sharedStyles Shared styles.\n * @param {boolean|undefined} showPointNames true to show names for point placemarks.\n * @return {import(\"../style/Style.js\").StyleFunction} Feature style function.\n */\nfunction createFeatureStyleFunction(\n  style,\n  styleUrl,\n  defaultStyle,\n  sharedStyles,\n  showPointNames\n) {\n  return (\n    /**\n     * @param {Feature} feature feature.\n     * @param {number} resolution Resolution.\n     * @return {Array<Style>|Style} Style.\n     */\n    function (feature, resolution) {\n      let drawName = showPointNames;\n      let name = '';\n      let multiGeometryPoints = [];\n      if (drawName) {\n        const geometry = feature.getGeometry();\n        if (geometry) {\n          if (geometry instanceof GeometryCollection) {\n            multiGeometryPoints = geometry\n              .getGeometriesArrayRecursive()\n              .filter(function (geometry) {\n                const type = geometry.getType();\n                return type === 'Point' || type === 'MultiPoint';\n              });\n            drawName = multiGeometryPoints.length > 0;\n          } else {\n            const type = geometry.getType();\n            drawName = type === 'Point' || type === 'MultiPoint';\n          }\n        }\n      }\n\n      if (drawName) {\n        name = /** @type {string} */ (feature.get('name'));\n        drawName = drawName && !!name;\n        // convert any html character codes\n        if (drawName && /&[^&]+;/.test(name)) {\n          if (!TEXTAREA) {\n            TEXTAREA = document.createElement('textarea');\n          }\n          TEXTAREA.innerHTML = name;\n          name = TEXTAREA.value;\n        }\n      }\n\n      let featureStyle = defaultStyle;\n      if (style) {\n        featureStyle = style;\n      } else if (styleUrl) {\n        featureStyle = findStyle(styleUrl, defaultStyle, sharedStyles);\n      }\n      if (drawName) {\n        const nameStyle = createNameStyleFunction(featureStyle[0], name);\n        if (multiGeometryPoints.length > 0) {\n          // in multigeometries restrict the name style to points and create a\n          // style without image or text for geometries requiring fill or stroke\n          // including any polygon specific style if there is one\n          nameStyle.setGeometry(new GeometryCollection(multiGeometryPoints));\n          const baseStyle = new Style({\n            geometry: featureStyle[0].getGeometry(),\n            image: null,\n            fill: featureStyle[0].getFill(),\n            stroke: featureStyle[0].getStroke(),\n            text: null,\n          });\n          return [nameStyle, baseStyle].concat(featureStyle.slice(1));\n        }\n        return nameStyle;\n      }\n      return featureStyle;\n    }\n  );\n}\n\n/**\n * @param {Array<Style>|string|undefined} styleValue Style value.\n * @param {Array<Style>} defaultStyle Default style.\n * @param {!Object<string, (Array<Style>|string)>} sharedStyles\n * Shared styles.\n * @return {Array<Style>} Style.\n */\nfunction findStyle(styleValue, defaultStyle, sharedStyles) {\n  if (Array.isArray(styleValue)) {\n    return styleValue;\n  } else if (typeof styleValue === 'string') {\n    return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);\n  } else {\n    return defaultStyle;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {import(\"../color.js\").Color|undefined} Color.\n */\nfunction readColor(node) {\n  const s = getAllTextContent(node, false);\n  // The KML specification states that colors should not include a leading `#`\n  // but we tolerate them.\n  const m = /^\\s*#?\\s*([0-9A-Fa-f]{8})\\s*$/.exec(s);\n  if (m) {\n    const hexColor = m[1];\n    return [\n      parseInt(hexColor.substr(6, 2), 16),\n      parseInt(hexColor.substr(4, 2), 16),\n      parseInt(hexColor.substr(2, 2), 16),\n      parseInt(hexColor.substr(0, 2), 16) / 255,\n    ];\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {Array<number>|undefined} Flat coordinates.\n */\nexport function readFlatCoordinates(node) {\n  let s = getAllTextContent(node, false);\n  const flatCoordinates = [];\n  // The KML specification states that coordinate tuples should not include\n  // spaces, but we tolerate them.\n  s = s.replace(/\\s*,\\s*/g, ',');\n  const re =\n    /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?),([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)(?:\\s+|,|$)(?:([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)(?:\\s+|$))?\\s*/i;\n  let m;\n  while ((m = re.exec(s))) {\n    const x = parseFloat(m[1]);\n    const y = parseFloat(m[2]);\n    const z = m[3] ? parseFloat(m[3]) : 0;\n    flatCoordinates.push(x, y, z);\n    s = s.substr(m[0].length);\n  }\n  if (s !== '') {\n    return undefined;\n  }\n  return flatCoordinates;\n}\n\n/**\n * @param {Node} node Node.\n * @return {string} URI.\n */\nfunction readURI(node) {\n  const s = getAllTextContent(node, false).trim();\n  let baseURI = node.baseURI;\n  if (!baseURI || baseURI == 'about:blank') {\n    baseURI = window.location.href;\n  }\n  if (baseURI) {\n    const url = new URL(s, baseURI);\n    return url.href;\n  } else {\n    return s;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {string} URI.\n */\nfunction readStyleURL(node) {\n  // KML files in the wild occasionally forget the leading\n  // `#` on styleUrlsdefined in the same document.\n  const s = getAllTextContent(node, false)\n    .trim()\n    .replace(/^(?!.*#)/, '#');\n  let baseURI = node.baseURI;\n  if (!baseURI || baseURI == 'about:blank') {\n    baseURI = window.location.href;\n  }\n  if (baseURI) {\n    const url = new URL(s, baseURI);\n    return url.href;\n  } else {\n    return s;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @return {Vec2} Vec2.\n */\nfunction readVec2(node) {\n  const xunits = node.getAttribute('xunits');\n  const yunits = node.getAttribute('yunits');\n  /** @type {import('../style/Icon.js').IconOrigin} */\n  let origin;\n  if (xunits !== 'insetPixels') {\n    if (yunits !== 'insetPixels') {\n      origin = 'bottom-left';\n    } else {\n      origin = 'top-left';\n    }\n  } else {\n    if (yunits !== 'insetPixels') {\n      origin = 'bottom-right';\n    } else {\n      origin = 'top-right';\n    }\n  }\n  return {\n    x: parseFloat(node.getAttribute('x')),\n    xunits: ICON_ANCHOR_UNITS_MAP[xunits],\n    y: parseFloat(node.getAttribute('y')),\n    yunits: ICON_ANCHOR_UNITS_MAP[yunits],\n    origin: origin,\n  };\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Scale.\n */\nfunction readScale(node) {\n  return readDecimal(node);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst STYLE_MAP_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Pair': pairDataParser,\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<Style>|string|undefined} StyleMap.\n */\nfunction readStyleMapValue(node, objectStack) {\n  return pushParseAndPop(undefined, STYLE_MAP_PARSERS, node, objectStack, this);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst ICON_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Icon': makeObjectPropertySetter(readIcon),\n  'color': makeObjectPropertySetter(readColor),\n  'heading': makeObjectPropertySetter(readDecimal),\n  'hotSpot': makeObjectPropertySetter(readVec2),\n  'scale': makeObjectPropertySetter(readScale),\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction iconStyleParser(node, objectStack) {\n  // FIXME refreshMode\n  // FIXME refreshInterval\n  // FIXME viewRefreshTime\n  // FIXME viewBoundScale\n  // FIXME viewFormat\n  // FIXME httpQuery\n  const object = pushParseAndPop({}, ICON_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = /** @type {Object} */ (\n    objectStack[objectStack.length - 1]\n  );\n  const IconObject = 'Icon' in object ? object['Icon'] : {};\n  const drawIcon = !('Icon' in object) || Object.keys(IconObject).length > 0;\n  let src;\n  const href = /** @type {string|undefined} */ (IconObject['href']);\n  if (href) {\n    src = href;\n  } else if (drawIcon) {\n    src = DEFAULT_IMAGE_STYLE_SRC;\n  }\n  let anchor, anchorXUnits, anchorYUnits;\n  /** @type {import('../style/Icon.js').IconOrigin|undefined} */\n  let anchorOrigin = 'bottom-left';\n  const hotSpot = /** @type {Vec2|undefined} */ (object['hotSpot']);\n  if (hotSpot) {\n    anchor = [hotSpot.x, hotSpot.y];\n    anchorXUnits = hotSpot.xunits;\n    anchorYUnits = hotSpot.yunits;\n    anchorOrigin = hotSpot.origin;\n  } else if (/^https?:\\/\\/maps\\.(?:google|gstatic)\\.com\\//.test(src)) {\n    // Google hotspots from https://kml4earth.appspot.com/icons.html#notes\n    if (src.includes('pushpin')) {\n      anchor = DEFAULT_IMAGE_STYLE_ANCHOR;\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    } else if (src.includes('arrow-reverse')) {\n      anchor = [54, 42];\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    } else if (src.includes('paddle')) {\n      anchor = [32, 1];\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    }\n  }\n\n  let offset;\n  const x = /** @type {number|undefined} */ (IconObject['x']);\n  const y = /** @type {number|undefined} */ (IconObject['y']);\n  if (x !== undefined && y !== undefined) {\n    offset = [x, y];\n  }\n\n  let size;\n  const w = /** @type {number|undefined} */ (IconObject['w']);\n  const h = /** @type {number|undefined} */ (IconObject['h']);\n  if (w !== undefined && h !== undefined) {\n    size = [w, h];\n  }\n\n  let rotation;\n  const heading = /** @type {number} */ (object['heading']);\n  if (heading !== undefined) {\n    rotation = toRadians(heading);\n  }\n\n  const scale = /** @type {number|undefined} */ (object['scale']);\n\n  const color = /** @type {Array<number>|undefined} */ (object['color']);\n\n  if (drawIcon) {\n    if (src == DEFAULT_IMAGE_STYLE_SRC) {\n      size = DEFAULT_IMAGE_STYLE_SIZE;\n    }\n\n    const imageStyle = new Icon({\n      anchor: anchor,\n      anchorOrigin: anchorOrigin,\n      anchorXUnits: anchorXUnits,\n      anchorYUnits: anchorYUnits,\n      crossOrigin: this.crossOrigin_,\n      offset: offset,\n      offsetOrigin: 'bottom-left',\n      rotation: rotation,\n      scale: scale,\n      size: size,\n      src: this.iconUrlFunction_(src),\n      color: color,\n    });\n\n    const imageScale = imageStyle.getScaleArray()[0];\n    const imageSize = imageStyle.getSize();\n    if (imageSize === null) {\n      const imageState = imageStyle.getImageState();\n      if (imageState === ImageState.IDLE || imageState === ImageState.LOADING) {\n        const listener = function () {\n          const imageState = imageStyle.getImageState();\n          if (\n            !(\n              imageState === ImageState.IDLE ||\n              imageState === ImageState.LOADING\n            )\n          ) {\n            const imageSize = imageStyle.getSize();\n            if (imageSize && imageSize.length == 2) {\n              const resizeScale = scaleForSize(imageSize);\n              imageStyle.setScale(imageScale * resizeScale);\n            }\n            imageStyle.unlistenImageChange(listener);\n          }\n        };\n        imageStyle.listenImageChange(listener);\n        if (imageState === ImageState.IDLE) {\n          imageStyle.load();\n        }\n      }\n    } else if (imageSize.length == 2) {\n      const resizeScale = scaleForSize(imageSize);\n      imageStyle.setScale(imageScale * resizeScale);\n    }\n    styleObject['imageStyle'] = imageStyle;\n  } else {\n    // handle the case when we explicitly want to draw no icon.\n    styleObject['imageStyle'] = DEFAULT_NO_IMAGE_STYLE;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'scale': makeObjectPropertySetter(readScale),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction labelStyleParser(node, objectStack) {\n  // FIXME colorMode\n  const object = pushParseAndPop({}, LABEL_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const textStyle = new Text({\n    fill: new Fill({\n      color:\n        /** @type {import(\"../color.js\").Color} */\n        ('color' in object ? object['color'] : DEFAULT_COLOR),\n    }),\n    scale: /** @type {number|undefined} */ (object['scale']),\n  });\n  styleObject['textStyle'] = textStyle;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LINE_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'width': makeObjectPropertySetter(readDecimal),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction lineStyleParser(node, objectStack) {\n  // FIXME colorMode\n  // FIXME gx:outerColor\n  // FIXME gx:outerWidth\n  // FIXME gx:physicalWidth\n  // FIXME gx:labelVisibility\n  const object = pushParseAndPop({}, LINE_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const strokeStyle = new Stroke({\n    color:\n      /** @type {import(\"../color.js\").Color} */\n      ('color' in object ? object['color'] : DEFAULT_COLOR),\n    width: /** @type {number} */ ('width' in object ? object['width'] : 1),\n  });\n  styleObject['strokeStyle'] = strokeStyle;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst POLY_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'fill': makeObjectPropertySetter(readBoolean),\n  'outline': makeObjectPropertySetter(readBoolean),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction polyStyleParser(node, objectStack) {\n  // FIXME colorMode\n  const object = pushParseAndPop({}, POLY_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const fillStyle = new Fill({\n    color:\n      /** @type {import(\"../color.js\").Color} */\n      ('color' in object ? object['color'] : DEFAULT_COLOR),\n  });\n  styleObject['fillStyle'] = fillStyle;\n  const fill = /** @type {boolean|undefined} */ (object['fill']);\n  if (fill !== undefined) {\n    styleObject['fill'] = fill;\n  }\n  const outline = /** @type {boolean|undefined} */ (object['outline']);\n  if (outline !== undefined) {\n    styleObject['outline'] = outline;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst FLAT_LINEAR_RING_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'coordinates': makeReplacer(readFlatCoordinates),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<number>} LinearRing flat coordinates.\n */\nfunction readFlatLinearRing(node, objectStack) {\n  return pushParseAndPop(null, FLAT_LINEAR_RING_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction gxCoordParser(node, objectStack) {\n  const gxTrackObject =\n    /** @type {GxTrackObject} */\n    (objectStack[objectStack.length - 1]);\n  const coordinates = gxTrackObject.coordinates;\n  const s = getAllTextContent(node, false);\n  const re =\n    /^\\s*([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s*$/i;\n  const m = re.exec(s);\n  if (m) {\n    const x = parseFloat(m[1]);\n    const y = parseFloat(m[2]);\n    const z = parseFloat(m[3]);\n    coordinates.push([x, y, z]);\n  } else {\n    coordinates.push([]);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GX_MULTITRACK_GEOMETRY_PARSERS = makeStructureNS(GX_NAMESPACE_URIS, {\n  'Track': makeArrayPusher(readGxTrack),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {MultiLineString|undefined} MultiLineString.\n */\nfunction readGxMultiTrack(node, objectStack) {\n  const lineStrings = pushParseAndPop(\n    [],\n    GX_MULTITRACK_GEOMETRY_PARSERS,\n    node,\n    objectStack\n  );\n  if (!lineStrings) {\n    return undefined;\n  }\n  return new MultiLineString(lineStrings);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GX_TRACK_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'when': whenParser,\n  },\n  makeStructureNS(GX_NAMESPACE_URIS, {\n    'coord': gxCoordParser,\n  })\n);\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {LineString|undefined} LineString.\n */\nfunction readGxTrack(node, objectStack) {\n  const gxTrackObject = pushParseAndPop(\n    /** @type {GxTrackObject} */ ({\n      coordinates: [],\n      whens: [],\n    }),\n    GX_TRACK_PARSERS,\n    node,\n    objectStack\n  );\n  if (!gxTrackObject) {\n    return undefined;\n  }\n  const flatCoordinates = [];\n  const coordinates = gxTrackObject.coordinates;\n  const whens = gxTrackObject.whens;\n  for (\n    let i = 0, ii = Math.min(coordinates.length, whens.length);\n    i < ii;\n    ++i\n  ) {\n    if (coordinates[i].length == 3) {\n      flatCoordinates.push(\n        coordinates[i][0],\n        coordinates[i][1],\n        coordinates[i][2],\n        whens[i]\n      );\n    }\n  }\n  return new LineString(flatCoordinates, 'XYZM');\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst ICON_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'href': makeObjectPropertySetter(readURI),\n  },\n  makeStructureNS(GX_NAMESPACE_URIS, {\n    'x': makeObjectPropertySetter(readDecimal),\n    'y': makeObjectPropertySetter(readDecimal),\n    'w': makeObjectPropertySetter(readDecimal),\n    'h': makeObjectPropertySetter(readDecimal),\n  })\n);\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object} Icon object.\n */\nfunction readIcon(node, objectStack) {\n  const iconObject = pushParseAndPop({}, ICON_PARSERS, node, objectStack);\n  if (iconObject) {\n    return iconObject;\n  } else {\n    return null;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GEOMETRY_FLAT_COORDINATES_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'coordinates': makeReplacer(readFlatCoordinates),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<number>} Flat coordinates.\n */\nfunction readFlatCoordinatesFromNode(node, objectStack) {\n  return pushParseAndPop(\n    null,\n    GEOMETRY_FLAT_COORDINATES_PARSERS,\n    node,\n    objectStack\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst EXTRUDE_AND_ALTITUDE_MODE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'extrude': makeObjectPropertySetter(readBoolean),\n  'tessellate': makeObjectPropertySetter(readBoolean),\n  'altitudeMode': makeObjectPropertySetter(readString),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {LineString|undefined} LineString.\n */\nfunction readLineString(node, objectStack) {\n  const properties = pushParseAndPop(\n    {},\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\n    node,\n    objectStack\n  );\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const lineString = new LineString(flatCoordinates, 'XYZ');\n    lineString.setProperties(properties, true);\n    return lineString;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Polygon|undefined} Polygon.\n */\nfunction readLinearRing(node, objectStack) {\n  const properties = pushParseAndPop(\n    {},\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\n    node,\n    objectStack\n  );\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const polygon = new Polygon(flatCoordinates, 'XYZ', [\n      flatCoordinates.length,\n    ]);\n    polygon.setProperties(properties, true);\n    return polygon;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst MULTI_GEOMETRY_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LineString': makeArrayPusher(readLineString),\n  'LinearRing': makeArrayPusher(readLinearRing),\n  'MultiGeometry': makeArrayPusher(readMultiGeometry),\n  'Point': makeArrayPusher(readPoint),\n  'Polygon': makeArrayPusher(readPolygon),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nfunction readMultiGeometry(node, objectStack) {\n  const geometries = pushParseAndPop(\n    [],\n    MULTI_GEOMETRY_PARSERS,\n    node,\n    objectStack\n  );\n  if (!geometries) {\n    return null;\n  }\n  if (geometries.length === 0) {\n    return new GeometryCollection(geometries);\n  }\n  let multiGeometry;\n  let homogeneous = true;\n  const type = geometries[0].getType();\n  let geometry;\n  for (let i = 1, ii = geometries.length; i < ii; ++i) {\n    geometry = geometries[i];\n    if (geometry.getType() != type) {\n      homogeneous = false;\n      break;\n    }\n  }\n  if (homogeneous) {\n    let layout;\n    let flatCoordinates;\n    if (type == 'Point') {\n      const point = geometries[0];\n      layout = point.getLayout();\n      flatCoordinates = point.getFlatCoordinates();\n      for (let i = 1, ii = geometries.length; i < ii; ++i) {\n        geometry = geometries[i];\n        extend(flatCoordinates, geometry.getFlatCoordinates());\n      }\n      multiGeometry = new MultiPoint(flatCoordinates, layout);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'LineString') {\n      multiGeometry = new MultiLineString(geometries);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'Polygon') {\n      multiGeometry = new MultiPolygon(geometries);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'GeometryCollection') {\n      multiGeometry = new GeometryCollection(geometries);\n    } else {\n      assert(false, 37); // Unknown geometry type found\n    }\n  } else {\n    multiGeometry = new GeometryCollection(geometries);\n  }\n  return /** @type {import(\"../geom/Geometry.js\").default} */ (multiGeometry);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Point|undefined} Point.\n */\nfunction readPoint(node, objectStack) {\n  const properties = pushParseAndPop(\n    {},\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\n    node,\n    objectStack\n  );\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const point = new Point(flatCoordinates, 'XYZ');\n    point.setProperties(properties, true);\n    return point;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst FLAT_LINEAR_RINGS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'innerBoundaryIs': innerBoundaryIsParser,\n  'outerBoundaryIs': outerBoundaryIsParser,\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Polygon|undefined} Polygon.\n */\nfunction readPolygon(node, objectStack) {\n  const properties = pushParseAndPop(\n    /** @type {Object<string,*>} */ ({}),\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\n    node,\n    objectStack\n  );\n  const flatLinearRings = pushParseAndPop(\n    [null],\n    FLAT_LINEAR_RINGS_PARSERS,\n    node,\n    objectStack\n  );\n  if (flatLinearRings && flatLinearRings[0]) {\n    const flatCoordinates = flatLinearRings[0];\n    const ends = [flatCoordinates.length];\n    for (let i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n      extend(flatCoordinates, flatLinearRings[i]);\n      ends.push(flatCoordinates.length);\n    }\n    const polygon = new Polygon(flatCoordinates, 'XYZ', ends);\n    polygon.setProperties(properties, true);\n    return polygon;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'IconStyle': iconStyleParser,\n  'LabelStyle': labelStyleParser,\n  'LineStyle': lineStyleParser,\n  'PolyStyle': polyStyleParser,\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<Style>} Style.\n */\nfunction readStyle(node, objectStack) {\n  const styleObject = pushParseAndPop(\n    {},\n    STYLE_PARSERS,\n    node,\n    objectStack,\n    this\n  );\n  if (!styleObject) {\n    return null;\n  }\n  let fillStyle =\n    /** @type {Fill} */\n    (\n      'fillStyle' in styleObject ? styleObject['fillStyle'] : DEFAULT_FILL_STYLE\n    );\n  const fill = /** @type {boolean|undefined} */ (styleObject['fill']);\n  if (fill !== undefined && !fill) {\n    fillStyle = null;\n  }\n  let imageStyle;\n  if ('imageStyle' in styleObject) {\n    if (styleObject['imageStyle'] != DEFAULT_NO_IMAGE_STYLE) {\n      imageStyle = styleObject['imageStyle'];\n    }\n  } else {\n    imageStyle = DEFAULT_IMAGE_STYLE;\n  }\n  const textStyle =\n    /** @type {Text} */\n    (\n      'textStyle' in styleObject ? styleObject['textStyle'] : DEFAULT_TEXT_STYLE\n    );\n  const strokeStyle =\n    /** @type {Stroke} */\n    (\n      'strokeStyle' in styleObject\n        ? styleObject['strokeStyle']\n        : DEFAULT_STROKE_STYLE\n    );\n  const outline = /** @type {boolean|undefined} */ (styleObject['outline']);\n  if (outline !== undefined && !outline) {\n    // if the polystyle specifies no outline two styles are needed,\n    // one for non-polygon geometries where linestrings require a stroke\n    // and one for polygons where there should be no stroke\n    return [\n      new Style({\n        geometry: function (feature) {\n          const geometry = feature.getGeometry();\n          const type = geometry.getType();\n          if (type === 'GeometryCollection') {\n            const collection =\n              /** @type {import(\"../geom/GeometryCollection\").default} */ (\n                geometry\n              );\n            return new GeometryCollection(\n              collection\n                .getGeometriesArrayRecursive()\n                .filter(function (geometry) {\n                  const type = geometry.getType();\n                  return type !== 'Polygon' && type !== 'MultiPolygon';\n                })\n            );\n          } else if (type !== 'Polygon' && type !== 'MultiPolygon') {\n            return geometry;\n          }\n        },\n        fill: fillStyle,\n        image: imageStyle,\n        stroke: strokeStyle,\n        text: textStyle,\n        zIndex: undefined, // FIXME\n      }),\n      new Style({\n        geometry: function (feature) {\n          const geometry = feature.getGeometry();\n          const type = geometry.getType();\n          if (type === 'GeometryCollection') {\n            const collection =\n              /** @type {import(\"../geom/GeometryCollection\").default} */ (\n                geometry\n              );\n            return new GeometryCollection(\n              collection\n                .getGeometriesArrayRecursive()\n                .filter(function (geometry) {\n                  const type = geometry.getType();\n                  return type === 'Polygon' || type === 'MultiPolygon';\n                })\n            );\n          } else if (type === 'Polygon' || type === 'MultiPolygon') {\n            return geometry;\n          }\n        },\n        fill: fillStyle,\n        stroke: null,\n        zIndex: undefined, // FIXME\n      }),\n    ];\n  }\n  return [\n    new Style({\n      fill: fillStyle,\n      image: imageStyle,\n      stroke: strokeStyle,\n      text: textStyle,\n      zIndex: undefined, // FIXME\n    }),\n  ];\n}\n\n/**\n * Reads an array of geometries and creates arrays for common geometry\n * properties. Then sets them to the multi geometry.\n * @param {MultiPoint|MultiLineString|MultiPolygon} multiGeometry A multi-geometry.\n * @param {Array<import(\"../geom/Geometry.js\").default>} geometries List of geometries.\n */\nfunction setCommonGeometryProperties(multiGeometry, geometries) {\n  const ii = geometries.length;\n  const extrudes = new Array(geometries.length);\n  const tessellates = new Array(geometries.length);\n  const altitudeModes = new Array(geometries.length);\n  let hasExtrude, hasTessellate, hasAltitudeMode;\n  hasExtrude = false;\n  hasTessellate = false;\n  hasAltitudeMode = false;\n  for (let i = 0; i < ii; ++i) {\n    const geometry = geometries[i];\n    extrudes[i] = geometry.get('extrude');\n    tessellates[i] = geometry.get('tessellate');\n    altitudeModes[i] = geometry.get('altitudeMode');\n    hasExtrude = hasExtrude || extrudes[i] !== undefined;\n    hasTessellate = hasTessellate || tessellates[i] !== undefined;\n    hasAltitudeMode = hasAltitudeMode || altitudeModes[i];\n  }\n  if (hasExtrude) {\n    multiGeometry.set('extrude', extrudes);\n  }\n  if (hasTessellate) {\n    multiGeometry.set('tessellate', tessellates);\n  }\n  if (hasAltitudeMode) {\n    multiGeometry.set('altitudeMode', altitudeModes);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'displayName': makeObjectPropertySetter(readString),\n  'value': makeObjectPropertySetter(readString),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction dataParser(node, objectStack) {\n  const name = node.getAttribute('name');\n  parseNode(DATA_PARSERS, node, objectStack);\n  const featureObject = /** @type {Object} */ (\n    objectStack[objectStack.length - 1]\n  );\n  if (name && featureObject.displayName) {\n    featureObject[name] = {\n      value: featureObject.value,\n      displayName: featureObject.displayName,\n      toString: function () {\n        return featureObject.value;\n      },\n    };\n  } else if (name !== null) {\n    featureObject[name] = featureObject.value;\n  } else if (featureObject.displayName !== null) {\n    featureObject[featureObject.displayName] = featureObject.value;\n  }\n  delete featureObject['value'];\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst EXTENDED_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Data': dataParser,\n  'SchemaData': schemaDataParser,\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction extendedDataParser(node, objectStack) {\n  parseNode(EXTENDED_DATA_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction regionParser(node, objectStack) {\n  parseNode(REGION_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PAIR_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Style': makeObjectPropertySetter(readStyle),\n  'key': makeObjectPropertySetter(readString),\n  'styleUrl': makeObjectPropertySetter(readStyleURL),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction pairDataParser(node, objectStack) {\n  const pairObject = pushParseAndPop({}, PAIR_PARSERS, node, objectStack, this);\n  if (!pairObject) {\n    return;\n  }\n  const key = /** @type {string|undefined} */ (pairObject['key']);\n  if (key && key == 'normal') {\n    const styleUrl = /** @type {string|undefined} */ (pairObject['styleUrl']);\n    if (styleUrl) {\n      objectStack[objectStack.length - 1] = styleUrl;\n    }\n    const style = /** @type {Style} */ (pairObject['Style']);\n    if (style) {\n      objectStack[objectStack.length - 1] = style;\n    }\n  }\n}\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction placemarkStyleMapParser(node, objectStack) {\n  const styleMapValue = readStyleMapValue.call(this, node, objectStack);\n  if (!styleMapValue) {\n    return;\n  }\n  const placemarkObject = objectStack[objectStack.length - 1];\n  if (Array.isArray(styleMapValue)) {\n    placemarkObject['Style'] = styleMapValue;\n  } else if (typeof styleMapValue === 'string') {\n    placemarkObject['styleUrl'] = styleMapValue;\n  } else {\n    assert(false, 38); // `styleMapValue` has an unknown type\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst SCHEMA_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'SimpleData': simpleDataParser,\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction schemaDataParser(node, objectStack) {\n  parseNode(SCHEMA_DATA_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction simpleDataParser(node, objectStack) {\n  const name = node.getAttribute('name');\n  if (name !== null) {\n    const data = readString(node);\n    const featureObject = /** @type {Object} */ (\n      objectStack[objectStack.length - 1]\n    );\n    featureObject[name] = data;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LAT_LON_ALT_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'altitudeMode': makeObjectPropertySetter(readString),\n  'minAltitude': makeObjectPropertySetter(readDecimal),\n  'maxAltitude': makeObjectPropertySetter(readDecimal),\n  'north': makeObjectPropertySetter(readDecimal),\n  'south': makeObjectPropertySetter(readDecimal),\n  'east': makeObjectPropertySetter(readDecimal),\n  'west': makeObjectPropertySetter(readDecimal),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction latLonAltBoxParser(node, objectStack) {\n  const object = pushParseAndPop(\n    {},\n    LAT_LON_ALT_BOX_PARSERS,\n    node,\n    objectStack\n  );\n  if (!object) {\n    return;\n  }\n  const regionObject = /** @type {Object} */ (\n    objectStack[objectStack.length - 1]\n  );\n  const extent = [\n    parseFloat(object['west']),\n    parseFloat(object['south']),\n    parseFloat(object['east']),\n    parseFloat(object['north']),\n  ];\n  regionObject['extent'] = extent;\n  regionObject['altitudeMode'] = object['altitudeMode'];\n  regionObject['minAltitude'] = parseFloat(object['minAltitude']);\n  regionObject['maxAltitude'] = parseFloat(object['maxAltitude']);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LOD_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'minLodPixels': makeObjectPropertySetter(readDecimal),\n  'maxLodPixels': makeObjectPropertySetter(readDecimal),\n  'minFadeExtent': makeObjectPropertySetter(readDecimal),\n  'maxFadeExtent': makeObjectPropertySetter(readDecimal),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction lodParser(node, objectStack) {\n  const object = pushParseAndPop({}, LOD_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const lodObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  lodObject['minLodPixels'] = parseFloat(object['minLodPixels']);\n  lodObject['maxLodPixels'] = parseFloat(object['maxLodPixels']);\n  lodObject['minFadeExtent'] = parseFloat(object['minFadeExtent']);\n  lodObject['maxFadeExtent'] = parseFloat(object['maxFadeExtent']);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst INNER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  // KML spec only allows one LinearRing  per innerBoundaryIs, but Google Earth\n  // allows multiple, so we parse multiple here too.\n  'LinearRing': makeArrayPusher(readFlatLinearRing),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction innerBoundaryIsParser(node, objectStack) {\n  const innerBoundaryFlatLinearRings = pushParseAndPop(\n    /** @type {Array<Array<number>>} */ ([]),\n    INNER_BOUNDARY_IS_PARSERS,\n    node,\n    objectStack\n  );\n  if (innerBoundaryFlatLinearRings.length > 0) {\n    const flatLinearRings =\n      /** @type {Array<Array<number>>} */\n      (objectStack[objectStack.length - 1]);\n    flatLinearRings.push(...innerBoundaryFlatLinearRings);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst OUTER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LinearRing': makeReplacer(readFlatLinearRing),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction outerBoundaryIsParser(node, objectStack) {\n  /** @type {Array<number>|undefined} */\n  const flatLinearRing = pushParseAndPop(\n    undefined,\n    OUTER_BOUNDARY_IS_PARSERS,\n    node,\n    objectStack\n  );\n  if (flatLinearRing) {\n    const flatLinearRings =\n      /** @type {Array<Array<number>>} */\n      (objectStack[objectStack.length - 1]);\n    flatLinearRings[0] = flatLinearRing;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction linkParser(node, objectStack) {\n  parseNode(LINK_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction whenParser(node, objectStack) {\n  const gxTrackObject =\n    /** @type {GxTrackObject} */\n    (objectStack[objectStack.length - 1]);\n  const whens = gxTrackObject.whens;\n  const s = getAllTextContent(node, false);\n  const when = Date.parse(s);\n  whens.push(isNaN(when) ? 0 : when);\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the color to.\n * @param {import(\"../color.js\").Color|string} color Color.\n */\nfunction writeColorTextNode(node, color) {\n  const rgba = asArray(color);\n  const opacity = rgba.length == 4 ? rgba[3] : 1;\n  /** @type {Array<string|number>} */\n  const abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];\n  for (let i = 0; i < 4; ++i) {\n    const hex = Math.floor(/** @type {number} */ (abgr[i])).toString(16);\n    abgr[i] = hex.length == 1 ? '0' + hex : hex;\n  }\n  writeStringTextNode(node, abgr.join(''));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the coordinates to.\n * @param {Array<number>} coordinates Coordinates.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeCoordinatesTextNode(node, coordinates, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n\n  const layout = context['layout'];\n  const stride = context['stride'];\n\n  let dimension;\n  if (layout == 'XY' || layout == 'XYM') {\n    dimension = 2;\n  } else if (layout == 'XYZ' || layout == 'XYZM') {\n    dimension = 3;\n  } else {\n    assert(false, 34); // Invalid geometry layout\n  }\n\n  const ii = coordinates.length;\n  let text = '';\n  if (ii > 0) {\n    text += coordinates[0];\n    for (let d = 1; d < dimension; ++d) {\n      text += ',' + coordinates[d];\n    }\n    for (let i = stride; i < ii; i += stride) {\n      text += ' ' + coordinates[i];\n      for (let d = 1; d < dimension; ++d) {\n        text += ',' + coordinates[i + d];\n      }\n    }\n  }\n  writeStringTextNode(node, text);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst EXTENDEDDATA_NODE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Data': makeChildAppender(writeDataNode),\n  'value': makeChildAppender(writeDataNodeValue),\n  'displayName': makeChildAppender(writeDataNodeName),\n});\n\n/**\n * @param {Element} node Node.\n * @param {{name: *, value: *}} pair Name value pair.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeDataNode(node, pair, objectStack) {\n  node.setAttribute('name', pair.name);\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const value = pair.value;\n\n  if (typeof value == 'object') {\n    if (value !== null && value.displayName) {\n      pushSerializeAndPop(\n        context,\n        EXTENDEDDATA_NODE_SERIALIZERS,\n        OBJECT_PROPERTY_NODE_FACTORY,\n        [value.displayName],\n        objectStack,\n        ['displayName']\n      );\n    }\n\n    if (value !== null && value.value) {\n      pushSerializeAndPop(\n        context,\n        EXTENDEDDATA_NODE_SERIALIZERS,\n        OBJECT_PROPERTY_NODE_FACTORY,\n        [value.value],\n        objectStack,\n        ['value']\n      );\n    }\n  } else {\n    pushSerializeAndPop(\n      context,\n      EXTENDEDDATA_NODE_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      [value],\n      objectStack,\n      ['value']\n    );\n  }\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the name to.\n * @param {string} name DisplayName.\n */\nfunction writeDataNodeName(node, name) {\n  writeCDATASection(node, name);\n}\n\n/**\n * @param {Node} node Node to append a CDATA Section with the value to.\n * @param {string} value Value.\n */\nfunction writeDataNodeValue(node, value) {\n  writeStringTextNode(node, value);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst DOCUMENT_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Placemark': makeChildAppender(writePlacemark),\n});\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst DOCUMENT_NODE_FACTORY = function (value, objectStack, nodeName) {\n  const parentNode = objectStack[objectStack.length - 1].node;\n  return createElementNS(parentNode.namespaceURI, 'Placemark');\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<Feature>} features Features.\n * @param {Array<*>} objectStack Object stack.\n * @this {KML}\n */\nfunction writeDocument(node, features, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  pushSerializeAndPop(\n    context,\n    DOCUMENT_SERIALIZERS,\n    DOCUMENT_NODE_FACTORY,\n    features,\n    objectStack,\n    undefined,\n    this\n  );\n}\n\n/**\n * A factory for creating Data nodes.\n * @const\n * @type {function(*, Array<*>): (Node|undefined)}\n */\nconst DATA_NODE_FACTORY = makeSimpleNodeFactory('Data');\n\n/**\n * @param {Element} node Node.\n * @param {{names: Array<string>, values: (Array<*>)}} namesAndValues Names and values.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeExtendedData(node, namesAndValues, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const names = namesAndValues.names;\n  const values = namesAndValues.values;\n  const length = names.length;\n\n  for (let i = 0; i < length; i++) {\n    pushSerializeAndPop(\n      context,\n      EXTENDEDDATA_NODE_SERIALIZERS,\n      DATA_NODE_FACTORY,\n      [{name: names[i], value: values[i]}],\n      objectStack\n    );\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst ICON_SEQUENCE = makeStructureNS(\n  NAMESPACE_URIS,\n  ['href'],\n  makeStructureNS(GX_NAMESPACE_URIS, ['x', 'y', 'w', 'h'])\n);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst ICON_SERIALIZERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'href': makeChildAppender(writeStringTextNode),\n  },\n  makeStructureNS(GX_NAMESPACE_URIS, {\n    'x': makeChildAppender(writeDecimalTextNode),\n    'y': makeChildAppender(writeDecimalTextNode),\n    'w': makeChildAppender(writeDecimalTextNode),\n    'h': makeChildAppender(writeDecimalTextNode),\n  })\n);\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst GX_NODE_FACTORY = function (value, objectStack, nodeName) {\n  return createElementNS(GX_NAMESPACE_URIS[0], 'gx:' + nodeName);\n};\n\n/**\n * @param {Element} node Node.\n * @param {Object} icon Icon object.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeIcon(node, icon, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const parentNode = objectStack[objectStack.length - 1].node;\n  let orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];\n  let values = makeSequence(icon, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    ICON_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n  orderedKeys = ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];\n  values = makeSequence(icon, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    ICON_SERIALIZERS,\n    GX_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst ICON_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'scale',\n  'heading',\n  'Icon',\n  'color',\n  'hotSpot',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst ICON_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Icon': makeChildAppender(writeIcon),\n  'color': makeChildAppender(writeColorTextNode),\n  'heading': makeChildAppender(writeDecimalTextNode),\n  'hotSpot': makeChildAppender(writeVec2),\n  'scale': makeChildAppender(writeScaleTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../style/Icon.js\").default} style Icon style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeIconStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const /** @type {Object<string, any>} */ properties = {};\n  const src = style.getSrc();\n  const size = style.getSize();\n  const iconImageSize = style.getImageSize();\n  const iconProperties = {\n    'href': src,\n  };\n\n  if (size) {\n    iconProperties['w'] = size[0];\n    iconProperties['h'] = size[1];\n    const anchor = style.getAnchor(); // top-left\n    const origin = style.getOrigin(); // top-left\n\n    if (origin && iconImageSize && origin[0] !== 0 && origin[1] !== size[1]) {\n      iconProperties['x'] = origin[0];\n      iconProperties['y'] = iconImageSize[1] - (origin[1] + size[1]);\n    }\n\n    if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {\n      const /** @type {Vec2} */ hotSpot = {\n          x: anchor[0],\n          xunits: 'pixels',\n          y: size[1] - anchor[1],\n          yunits: 'pixels',\n        };\n      properties['hotSpot'] = hotSpot;\n    }\n  }\n\n  properties['Icon'] = iconProperties;\n\n  let scale = style.getScaleArray()[0];\n  let imageSize = size;\n  if (imageSize === null) {\n    imageSize = DEFAULT_IMAGE_STYLE_SIZE;\n  }\n  if (imageSize.length == 2) {\n    const resizeScale = scaleForSize(imageSize);\n    scale = scale / resizeScale;\n  }\n  if (scale !== 1) {\n    properties['scale'] = scale;\n  }\n\n  const rotation = style.getRotation();\n  if (rotation !== 0) {\n    properties['heading'] = rotation; // 0-360\n  }\n\n  const color = style.getColor();\n  if (color) {\n    properties['color'] = color;\n  }\n\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    ICON_STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'color',\n  'scale',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'scale': makeChildAppender(writeScaleTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Text} style style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeLabelStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const properties = {};\n  const fill = style.getFill();\n  if (fill) {\n    properties['color'] = fill.getColor();\n  }\n  const scale = style.getScale();\n  if (scale && scale !== 1) {\n    properties['scale'] = scale;\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    LABEL_STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst LINE_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['color', 'width']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst LINE_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'width': makeChildAppender(writeDecimalTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Stroke} style style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeLineStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const properties = {\n    'color': style.getColor(),\n    'width': Number(style.getWidth()) || 1,\n  };\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    LINE_STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst GEOMETRY_TYPE_TO_NODENAME = {\n  'Point': 'Point',\n  'LineString': 'LineString',\n  'LinearRing': 'LinearRing',\n  'Polygon': 'Polygon',\n  'MultiPoint': 'MultiGeometry',\n  'MultiLineString': 'MultiGeometry',\n  'MultiPolygon': 'MultiGeometry',\n  'GeometryCollection': 'MultiGeometry',\n};\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst GEOMETRY_NODE_FACTORY = function (value, objectStack, nodeName) {\n  if (value) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\n      parentNode.namespaceURI,\n      GEOMETRY_TYPE_TO_NODENAME[\n        /** @type {import(\"../geom/Geometry.js\").default} */ (value).getType()\n      ]\n    );\n  }\n};\n\n/**\n * A factory for creating Point nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst POINT_NODE_FACTORY = makeSimpleNodeFactory('Point');\n\n/**\n * A factory for creating LineString nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst LINE_STRING_NODE_FACTORY = makeSimpleNodeFactory('LineString');\n\n/**\n * A factory for creating LinearRing nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst LINEAR_RING_NODE_FACTORY = makeSimpleNodeFactory('LinearRing');\n\n/**\n * A factory for creating Polygon nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst POLYGON_NODE_FACTORY = makeSimpleNodeFactory('Polygon');\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst MULTI_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'LineString': makeChildAppender(writePrimitiveGeometry),\n  'Point': makeChildAppender(writePrimitiveGeometry),\n  'Polygon': makeChildAppender(writePolygon),\n  'GeometryCollection': makeChildAppender(writeMultiGeometry),\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeMultiGeometry(node, geometry, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const context = {node: node};\n  const type = geometry.getType();\n  /** @type {Array<import(\"../geom/Geometry.js\").default>} */\n  let geometries = [];\n  /** @type {function(*, Array<*>, string=): (Node|undefined)} */\n  let factory;\n  if (type === 'GeometryCollection') {\n    /** @type {GeometryCollection} */ (geometry)\n      .getGeometriesArrayRecursive()\n      .forEach(function (geometry) {\n        const type = geometry.getType();\n        if (type === 'MultiPoint') {\n          geometries = geometries.concat(\n            /** @type {MultiPoint} */ (geometry).getPoints()\n          );\n        } else if (type === 'MultiLineString') {\n          geometries = geometries.concat(\n            /** @type {MultiLineString} */ (geometry).getLineStrings()\n          );\n        } else if (type === 'MultiPolygon') {\n          geometries = geometries.concat(\n            /** @type {MultiPolygon} */ (geometry).getPolygons()\n          );\n        } else if (\n          type === 'Point' ||\n          type === 'LineString' ||\n          type === 'Polygon'\n        ) {\n          geometries.push(geometry);\n        } else {\n          assert(false, 39); // Unknown geometry type\n        }\n      });\n    factory = GEOMETRY_NODE_FACTORY;\n  } else if (type === 'MultiPoint') {\n    geometries = /** @type {MultiPoint} */ (geometry).getPoints();\n    factory = POINT_NODE_FACTORY;\n  } else if (type === 'MultiLineString') {\n    geometries = /** @type {MultiLineString} */ (geometry).getLineStrings();\n    factory = LINE_STRING_NODE_FACTORY;\n  } else if (type === 'MultiPolygon') {\n    geometries = /** @type {MultiPolygon} */ (geometry).getPolygons();\n    factory = POLYGON_NODE_FACTORY;\n  } else {\n    assert(false, 39); // Unknown geometry type\n  }\n  pushSerializeAndPop(\n    context,\n    MULTI_GEOMETRY_SERIALIZERS,\n    factory,\n    geometries,\n    objectStack\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst BOUNDARY_IS_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'LinearRing': makeChildAppender(writePrimitiveGeometry),\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/LinearRing.js\").default} linearRing Linear ring.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeBoundaryIs(node, linearRing, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  pushSerializeAndPop(\n    context,\n    BOUNDARY_IS_SERIALIZERS,\n    LINEAR_RING_NODE_FACTORY,\n    [linearRing],\n    objectStack\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst PLACEMARK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'ExtendedData': makeChildAppender(writeExtendedData),\n  'MultiGeometry': makeChildAppender(writeMultiGeometry),\n  'LineString': makeChildAppender(writePrimitiveGeometry),\n  'LinearRing': makeChildAppender(writePrimitiveGeometry),\n  'Point': makeChildAppender(writePrimitiveGeometry),\n  'Polygon': makeChildAppender(writePolygon),\n  'Style': makeChildAppender(writeStyle),\n  'address': makeChildAppender(writeStringTextNode),\n  'description': makeChildAppender(writeStringTextNode),\n  'name': makeChildAppender(writeStringTextNode),\n  'open': makeChildAppender(writeBooleanTextNode),\n  'phoneNumber': makeChildAppender(writeStringTextNode),\n  'styleUrl': makeChildAppender(writeStringTextNode),\n  'visibility': makeChildAppender(writeBooleanTextNode),\n});\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst PLACEMARK_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'name',\n  'open',\n  'visibility',\n  'address',\n  'phoneNumber',\n  'description',\n  'styleUrl',\n  'Style',\n]);\n\n/**\n * A factory for creating ExtendedData nodes.\n * @const\n * @type {function(*, Array<*>): (Node|undefined)}\n */\nconst EXTENDEDDATA_NODE_FACTORY = makeSimpleNodeFactory('ExtendedData');\n\n/**\n * FIXME currently we do serialize arbitrary/custom feature properties\n * (ExtendedData).\n * @param {Element} node Node.\n * @param {Feature} feature Feature.\n * @param {Array<*>} objectStack Object stack.\n * @this {KML}\n */\nfunction writePlacemark(node, feature, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n\n  // set id\n  if (feature.getId()) {\n    node.setAttribute('id', /** @type {string} */ (feature.getId()));\n  }\n\n  // serialize properties (properties unknown to KML are not serialized)\n  const properties = feature.getProperties();\n\n  // don't export these to ExtendedData\n  const filter = {\n    'address': 1,\n    'description': 1,\n    'name': 1,\n    'open': 1,\n    'phoneNumber': 1,\n    'styleUrl': 1,\n    'visibility': 1,\n  };\n  filter[feature.getGeometryName()] = 1;\n  const keys = Object.keys(properties || {})\n    .sort()\n    .filter(function (v) {\n      return !filter[v];\n    });\n\n  const styleFunction = feature.getStyleFunction();\n  if (styleFunction) {\n    // FIXME the styles returned by the style function are supposed to be\n    // resolution-independent here\n    const styles = styleFunction(feature, 0);\n    if (styles) {\n      const styleArray = Array.isArray(styles) ? styles : [styles];\n      let pointStyles = styleArray;\n      if (feature.getGeometry()) {\n        pointStyles = styleArray.filter(function (style) {\n          const geometry = style.getGeometryFunction()(feature);\n          if (geometry) {\n            const type = geometry.getType();\n            if (type === 'GeometryCollection') {\n              return /** @type {GeometryCollection} */ (geometry)\n                .getGeometriesArrayRecursive()\n                .filter(function (geometry) {\n                  const type = geometry.getType();\n                  return type === 'Point' || type === 'MultiPoint';\n                }).length;\n            }\n            return type === 'Point' || type === 'MultiPoint';\n          }\n        });\n        ('Point');\n      }\n      if (this.writeStyles_) {\n        let lineStyles = styleArray;\n        let polyStyles = styleArray;\n        if (feature.getGeometry()) {\n          lineStyles = styleArray.filter(function (style) {\n            const geometry = style.getGeometryFunction()(feature);\n            if (geometry) {\n              const type = geometry.getType();\n              if (type === 'GeometryCollection') {\n                return /** @type {GeometryCollection} */ (geometry)\n                  .getGeometriesArrayRecursive()\n                  .filter(function (geometry) {\n                    const type = geometry.getType();\n                    return type === 'LineString' || type === 'MultiLineString';\n                  }).length;\n              }\n              return type === 'LineString' || type === 'MultiLineString';\n            }\n          });\n          polyStyles = styleArray.filter(function (style) {\n            const geometry = style.getGeometryFunction()(feature);\n            if (geometry) {\n              const type = geometry.getType();\n              if (type === 'GeometryCollection') {\n                return /** @type {GeometryCollection} */ (geometry)\n                  .getGeometriesArrayRecursive()\n                  .filter(function (geometry) {\n                    const type = geometry.getType();\n                    return type === 'Polygon' || type === 'MultiPolygon';\n                  }).length;\n              }\n              return type === 'Polygon' || type === 'MultiPolygon';\n            }\n          });\n        }\n        properties['Style'] = {\n          pointStyles: pointStyles,\n          lineStyles: lineStyles,\n          polyStyles: polyStyles,\n        };\n      }\n      if (pointStyles.length && properties['name'] === undefined) {\n        const textStyle = pointStyles[0].getText();\n        if (textStyle) {\n          properties['name'] = textStyle.getText();\n        }\n      }\n    }\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    PLACEMARK_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n\n  if (keys.length > 0) {\n    const sequence = makeSequence(properties, keys);\n    const namesAndValues = {names: keys, values: sequence};\n    pushSerializeAndPop(\n      context,\n      PLACEMARK_SERIALIZERS,\n      EXTENDEDDATA_NODE_FACTORY,\n      [namesAndValues],\n      objectStack\n    );\n  }\n\n  // serialize geometry\n  const options = /** @type {import(\"./Feature.js\").WriteOptions} */ (\n    objectStack[0]\n  );\n  let geometry = feature.getGeometry();\n  if (geometry) {\n    geometry = transformGeometryWithOptions(geometry, true, options);\n  }\n  pushSerializeAndPop(\n    context,\n    PLACEMARK_SERIALIZERS,\n    GEOMETRY_NODE_FACTORY,\n    [geometry],\n    objectStack\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst PRIMITIVE_GEOMETRY_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'extrude',\n  'tessellate',\n  'altitudeMode',\n  'coordinates',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst PRIMITIVE_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'extrude': makeChildAppender(writeBooleanTextNode),\n  'tessellate': makeChildAppender(writeBooleanTextNode),\n  'altitudeMode': makeChildAppender(writeStringTextNode),\n  'coordinates': makeChildAppender(writeCoordinatesTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePrimitiveGeometry(node, geometry, objectStack) {\n  const flatCoordinates = geometry.getFlatCoordinates();\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  context['layout'] = geometry.getLayout();\n  context['stride'] = geometry.getStride();\n\n  // serialize properties (properties unknown to KML are not serialized)\n  const properties = geometry.getProperties();\n  properties.coordinates = flatCoordinates;\n\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    PRIMITIVE_GEOMETRY_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst POLY_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'color',\n  'fill',\n  'outline',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst POLYGON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'outerBoundaryIs': makeChildAppender(writeBoundaryIs),\n  'innerBoundaryIs': makeChildAppender(writeBoundaryIs),\n});\n\n/**\n * A factory for creating innerBoundaryIs nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst INNER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory('innerBoundaryIs');\n\n/**\n * A factory for creating outerBoundaryIs nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst OUTER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory('outerBoundaryIs');\n\n/**\n * @param {Element} node Node.\n * @param {Polygon} polygon Polygon.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePolygon(node, polygon, objectStack) {\n  const linearRings = polygon.getLinearRings();\n  const outerRing = linearRings.shift();\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  // inner rings\n  pushSerializeAndPop(\n    context,\n    POLYGON_SERIALIZERS,\n    INNER_BOUNDARY_NODE_FACTORY,\n    linearRings,\n    objectStack\n  );\n  // outer ring\n  pushSerializeAndPop(\n    context,\n    POLYGON_SERIALIZERS,\n    OUTER_BOUNDARY_NODE_FACTORY,\n    [outerRing],\n    objectStack\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst POLY_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'fill': makeChildAppender(writeBooleanTextNode),\n  'outline': makeChildAppender(writeBooleanTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Style} style Style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePolyStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const fill = style.getFill();\n  const stroke = style.getStroke();\n  const properties = {\n    'color': fill ? fill.getColor() : undefined,\n    'fill': fill ? undefined : false,\n    'outline': stroke ? undefined : false,\n  };\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = POLY_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    POLY_STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the scale to.\n * @param {number|undefined} scale Scale.\n */\nfunction writeScaleTextNode(node, scale) {\n  // the Math is to remove any excess decimals created by float arithmetic\n  writeDecimalTextNode(node, Math.round(scale * 1e6) / 1e6);\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'IconStyle',\n  'LabelStyle',\n  'LineStyle',\n  'PolyStyle',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'IconStyle': makeChildAppender(writeIconStyle),\n  'LabelStyle': makeChildAppender(writeLabelStyle),\n  'LineStyle': makeChildAppender(writeLineStyle),\n  'PolyStyle': makeChildAppender(writePolyStyle),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Object<string, Array<Style>>} styles Styles.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeStyle(node, styles, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const properties = {};\n  if (styles.pointStyles.length) {\n    const textStyle = styles.pointStyles[0].getText();\n    if (textStyle) {\n      properties['LabelStyle'] = textStyle;\n    }\n    const imageStyle = styles.pointStyles[0].getImage();\n    if (\n      imageStyle &&\n      typeof (/** @type {?} */ (imageStyle).getSrc) === 'function'\n    ) {\n      properties['IconStyle'] = imageStyle;\n    }\n  }\n  if (styles.lineStyles.length) {\n    const strokeStyle = styles.lineStyles[0].getStroke();\n    if (strokeStyle) {\n      properties['LineStyle'] = strokeStyle;\n    }\n  }\n  if (styles.polyStyles.length) {\n    const strokeStyle = styles.polyStyles[0].getStroke();\n    if (strokeStyle && !properties['LineStyle']) {\n      properties['LineStyle'] = strokeStyle;\n    }\n    properties['PolyStyle'] = styles.polyStyles[0];\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @param {Element} node Node to append a TextNode with the Vec2 to.\n * @param {Vec2} vec2 Vec2.\n */\nfunction writeVec2(node, vec2) {\n  node.setAttribute('x', String(vec2.x));\n  node.setAttribute('y', String(vec2.y));\n  node.setAttribute('xunits', vec2.xunits);\n  node.setAttribute('yunits', vec2.yunits);\n}\n\nexport default KML;\n", "import d from \"./node_modules/ol/format/KML.js\";export default d;\nexport * from \"./node_modules/ol/format/KML.js\""],
  "mappings": "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",
  "names": ["Feature_default", "geometry", "imageState", "imageSize", "type"]
}
